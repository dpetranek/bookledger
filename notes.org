* action
** DONE books table schema
** DONE reviews table schema
** DONE implement insert-book
(session/get :userid) isn't actually returning the userid, I don't
believe. I've updated the auth workflow to load the whole user record into the
session as a map. Maybe that's the issue, that it's a map inside the map. 
---
I've fixed it by verifying that we're loading the whole user row as :user and
then use (:<columnIwant> (session/get :user)). That works, is a bit verbose,
but I'll refactor later.
** DONE fix double display of layout/common
So, I had show-library wrapped in layout/common. That caused everything to be
show twice. When I removed the wrapping, nothing showed at all.
---
I fixed this by realizing that a funtion only returns the last item. So I
wrapped the whole output in a div. It's a hack, but it works for now.

** DONE allow blank inputs
I need to do some validation. So, I've changed the handler so POST to /libray
goes to handle-request. It just submits the whole request map. By having VALUES
of the query be key lookups, I was able to get it working as before.

Then I started some validation. I added an if statement to series, returning
"null" if (:series request-map) was falsey. That worked wonderfully. Then I tried
to do the same with seriesnum. Things stopped working. I changed it to return
nil instead of "null", and now I can submit blank series and blank
seriesnum. However, now author and title are returning nil too, for some reason
I can't readily divine. I'm going to change it back and see if I can get the
previous behavior.

Ok, I think it's a problem with the request map, actually. Something has
changed in how the browser is submitting data - I think it's empty. When I
click on the POST request in the console, there is no params section. I'm tired
and my head is not working well, I'll come at this tomorrow.

---

Make sure that all the network access logging option are checked in the browser
console. I am sending data.
---
So it looks like I was trying to get at nested data. Adding (:params request) to
the handle-books invocation in home.clj fixed the data access issues. And now I
can handle blanks thanks to helper functions. 

I was able to debug by looking at the database using the repl. In psql, blank
columns are just blank, so I couldn't tell the difference between nil and
"". But with (sql/query db-spec ["<query>"], I was able to see what actual
clojure data was stored. After that, it was just mop-up.
** DONE design add-book form
title
authorf authorl
series seriesnum
rating
date
synopsis
comment

this will collect information for both the books table insert and the reviews
table insert. This will be on its own seperate page. 
** DONE implement insert-review
make sure to add exception handling later
** DONE get dates to work
** DONE display books left join reviews
or is it right join? I need to figure out how to find duplicate books.
** TODO verify no duplicate books
may need to alter the books schema so title+authorl+authorf+userid is the
key. Update row, catch exceptions, and then insert new row. 

This is prone to race conditions, though. 
** TODO implement tags
add each unique tag to the user record
add multiple tags to a book record 
** TODO account settings
** TODO deletion
- [ ] delete user
- [ ] delete item
** TODO mass export
- [ ] allow export at any time
- [ ] full csv of all data
# COPY books left join reviews TO <filename>
** TODO get a date-picker
** TODO search
** TODO filter
** TODO deploy
heroku
* implementation details
** db
*** cheese
Each user will have their own book table and book-meta table. Actually, I could
have the book table be global table, and try to match. That could save
space. But that might be premature. 

I'll go with one table per user, not a shared one. That will avoid privacy
issues and simplify the design. I can revisit that later.

I'll also remove email from the user table for now. I don't want to store emails
unless I have a verification set up, and I don't want to do that right off the
bat, though eventually I will have to handle it.

---
It's turning out to be difficult to add unique ids to the table. I think it's
just a syntax mixup, but I'm getting tired and it's not making sense. Do I need
userids? Is it just a convenience? If the usernames are going to be unique
anyways, what's the point?

(defn create-users-table []
  (sql/with-connection db
    (sql/create-table
     :users
     [:userid :serial "PRIMARY KEY"]
     [:username "varchar(50)"]
     [:pass "varchar(100)"])))

this funtion produces a valid psql command, but it returns an error. For now,
I'll just go with username and pass. We'll circle back later. That sucks though!
I'll have to restructure anything that references the user database. I'll take
another stab at making it work.

--- 

I ended up updating the database driver from 2.3 to 3.6. I had to read the new
api, but I found what works. It also didn't help that the db spec was
incorrectly defined. 

---

Inserting into two tables requires returning the bookid from the books table so
we can include it on the insert into the reviews table. Ideally, this is what I
want:

INSERT INTO books (userid, title) VALUES (<vals>) RETURNING bookid;

However, I can't do that with java.jdbc. At least, I've not been able to figure
it out. I'll ask in IRC, but I'm not confident I'll get a useful response. The
runner up solutions use curval() and lastval(), but I haven't been able to get
those to work. What I have gotten to work is this:

(sql/query db-spec ["SELECT max(bookid) FROM books"])

That will have to do for now. Reference:
http://stackoverflow.com/questions/2944297/postgresql-function-for-last-inserted-id

---

It's just occurred to me that I've got the database set up with a shared books
and reviews table. I think that's okay, I'll just need make sure I don't
accidentally expose information of other users, especially during search. This
could mess up my method of getting the last bookid, though. I may need to
redesign the book schema to use title+authorl+authorf as the key.

--- 

I've been thinking about how to implement tags. It's basically just a list of
keywords associated with the :tags key. However, if I'd like to do
auto-complete then I can't be searching through every entry like this: 
book: tags: <list of tags>. That won't scale at all, and it's inelegant
besides. So I'm thinking about adding new keys to the user record - it'll have
a list of all the keys the user has used. I'll also add them to the book record
as necessary.
*** setup
with psql
sudo su postgres
# CREATE ROLE bookledger WITH LOGIN PASSWORD 'admin';
# CREATE DATABASE bookledger OWNER bookledger;

psql bookledger
\dt
\q
*** schema
- user table: the user table will just be usernames and password hashes
  userid [int][pk]
  username [text]
  pass hash [text]

- book table: unique information about a single book; belongs to a user
  book id [int][pk]
  user id [int]
  title [text]
  author [text]
  permission [binary]
  tags [vector]
  series [text]
  seriesnum [int]

- review table: unique information about a single reading; belongs to a user
  and a book 
  review id [int][pk]
  user id [int]
  book id [int]
  date modified [date]
  rating [int]
  comment [text]
*** queries
- homepage
  SELECT * FROM books LEFT JOIN reviews ON books.bookid = reviews.bookid WHERE
  books.userid = :userid ORDER BY reviews.dateRead
** stats
- how many books did I read in <time period>?
- what genre do I read the most?
- what author do like the best?
- what books do I keep coming back to?
- what author have I read the most?
- who has recommended books to me?
- who's recommendations did I enjoy the most?
- what books have I loaned out? To whom?
- when do I read the most?
- how have my views on this book? How has that changed over time?
- what do I think of this author? How has that changed over time?
** user privacy
to start, no users will be able to see anything belonging to another user. I
would like to add granular privacy controls, though. Mark these books as
public, mark these reviews as public, mark these fields as public. Also offer
some sensible defaults - all private. 

- policy
  I don't want your information - it's yours. 
** introduction
Bookledger - track your reading.

Hello! I like to read books. I keep track of books I've read and I'd like to
learn about my reading patterns. I get recommendations from friends, but
sometimes I forget. So I built bookledger, a place to track the books you've
read and the books you want read, and an easy way to learn some nifty things
about your reading patterns. 
** functionality
- Auth
  - registration
  - login
  - logout
- Add
  - add book record
  - bulk upload
    - should mirror the export
    - each row is like a left join of books and reviews
- Filter + Sort
  - by a reasonable number of fields
- Search
  - incremental search with suggestions
  - advanced search - specify search logic
- Explore
  - Use links on records to browse to other similar records, wiki style
- Settings
  - granular privacy
    - what fields are visible to those you share with - circles
    - who you share with
  - password reset
  - export
  - account deletion
- Library management
  - track books loaned to friends
  - track books received from friends
** greenfield
- book discussion pages
- self-hosting
** layout

